<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>watchersworld.client documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avaoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);

               if ($darkModeToggles.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-block d-sm-none">
            <a href="../" class="navbar-brand">watchersworld.client documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  MovieCategory</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/profile/profile/profile.component.ts</code>
        </p>




        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#activeIndex" 
>
                                            activeIndex
                                        </a>
                                </li>
                                <li>
                                        <a href="#media_type" 
>
                                            media_type
                                        </a>
                                </li>
                                <li>
                                        <a href="#name" 
>
                                            name
                                        </a>
                                </li>
                                <li>
                                        <a href="#results" 
>
                                            results
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="activeIndex"></a>
                                        <span class="name "><b>activeIndex</b>
                                            <a href="#activeIndex">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>activeIndex:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="media_type"></a>
                                        <span class="name "><b>media_type</b>
                                            <a href="#media_type">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>media_type:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="name"></a>
                                        <span class="name "><b>name</b>
                                            <a href="#name">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>name:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="results"></a>
                                        <span class="name "><b>results</b>
                                            <a href="#results">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>results:     <code>any[]</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>any[]</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, OnInit } from &#x27;@angular/core&#x27;;
import { ProfileService } from &#x27;../services/profile.service&#x27;;
import { Profile } from &#x27;../models/profile&#x27;;
import { FormBuilder, FormGroup, Validators } from &#x27;@angular/forms&#x27;;
import { Subject, catchError, firstValueFrom, forkJoin, map, mergeMap, of, takeUntil } from &#x27;rxjs&#x27;;
import { ActivatedRoute } from &#x27;@angular/router&#x27;;
import { AuthenticationService } from &#x27;../../authentication/services/authentication.service&#x27;;
import { FollowerProfile } from &#x27;../models/follower-profile&#x27;;
import { MovieApiServiceComponent } from &#x27;../../media/api/movie-api-service/movie-api-service.component&#x27;;
import { UserMedia } from &#x27;../models/user-media&#x27;;
import { Title } from &#x27;@angular/platform-browser&#x27;;
import { AdminService } from &#x27;../../admin/service/admin.service&#x27;;
import { NotificationService } from &#x27;../../notifications/services/notification.service&#x27;;
import { GamificationService } from &#x27;../../gamification/Service/gamification.service&#x27;;
import { ChatService } from &#x27;../../chat/services/chat.service&#x27;;
import { ProfileChat } from &#x27;../../chat/models/profileChat&#x27;;

interface MovieCategory {
  name: string;
  results: any[];
  activeIndex: number;
  media_type: string;
}

/**
 * Componente para a página de perfil do utilizador.
 * Permite visualizar e interagir com o perfil do utilizador, incluindo seguir/desseguir, enviar mensagens e visualizar media favorita.
 */
@Component({
  selector: &#x27;app-profile&#x27;,
  templateUrl: &#x27;./profile.component.html&#x27;,
  styleUrl: &#x27;./profile.component.css&#x27;
})
export class ProfileComponent implements OnInit {

  currentUsername: string | undefined;
  loggedUserName: string | null &#x3D; null;
  isFollowing: boolean &#x3D; false;
  loggedUserProfile: Profile | undefined;
  userPhoto: string | null &#x3D; null;

  profileForm: FormGroup &#x3D; new FormGroup({});

  private unsubscribed$ &#x3D; new Subject&lt;void&gt;();

  message: string | undefined;
  errorMessages: any;

  usersProfiles: Profile[] &#x3D; [];

  followersCount: number | undefined;
  followingCount: number | undefined;

  canViewData: boolean &#x3D; false;
  isFollowRequestApproved: boolean &#x3D; false;
  isProfilePublic: string | undefined;
  followRequestSent: boolean &#x3D; false;

  showFollowers: boolean &#x3D; true;
  showFollowing: boolean &#x3D; true;

  showFavorites: boolean &#x3D; true;
  showAllFavorites: boolean &#x3D; false;

  showMoviesWatched: boolean &#x3D; true;
  showAllMoviesWatched: boolean &#x3D; false;

  showMoviesToWatch: boolean &#x3D; true;
  showAllMoviesToWatch: boolean &#x3D; false;

  showSeriesWatched: boolean &#x3D; true;
  showAllSeriesWatched: boolean &#x3D; false;

  showSeriesToWatch: boolean &#x3D; true;
  showAllSeriesToWatch: boolean &#x3D; false;

  showMedals: boolean &#x3D; true;

  expandedFollowers: boolean &#x3D; false;
  expandedFollowing: boolean &#x3D; false;

  expandedFavoritesList: boolean &#x3D; false;

  expandedMoviesWatchList: boolean &#x3D; false;
  expandedMoviesToWatchList: boolean &#x3D; false;

  expandedSeriesWatchList: boolean &#x3D; false;
  expandedSeriesToWatchList: boolean &#x3D; false;

  followers: FollowerProfile[] &#x3D; [];
  following: FollowerProfile[] &#x3D; [];

  showAllFollowing &#x3D; false;
  showAllFollowers &#x3D; false;
  showFiveOtherUsers &#x3D; false;
  showExpandedSuggestions &#x3D; false;

  categories: MovieCategory[] &#x3D; [];
  favoriteMovies: any[] &#x3D; [];
  favoriteSeries: any[] &#x3D; [];
  watchedMovies: any[] &#x3D; [];
  watchedSeries: any[] &#x3D; [];
  watchLaterMovies: any[] &#x3D; [];
  watchLaterSeries: any[] &#x3D; [];
  getMovieDetailResult: any;

  isBanPopupVisible &#x3D; false;
  isModerator: boolean &#x3D; false;
  banDuration: number | undefined;
  isBanned?: boolean;
  selectedUserForBan: string | null &#x3D; null;

  usersProfilesMod: Profile[] &#x3D; [];
  filteredUsersProfiles: Profile[] &#x3D; [];
  searchTerm: string &#x3D; &#x27;&#x27;;
  showNoResults: boolean &#x3D; false;
  selectedUser: Profile | undefined;
  selectedUsername: string | null &#x3D; null;

  page: number &#x3D; 1;
  pageSize: number &#x3D; 5;
  collectionSize!: number;

  medals: any[] &#x3D; [];
  showAllMedals &#x3D; false;

  /**
 * Construtor do componente ProfileComponent.
 * Inicializa os serviços e ferramentas necessárias para a gestão do perfil do utilizador.
 * @param profileService Serviço para interação com dados de perfil do utilizador.
 * @param chatService Serviço para gestão de mensagens e chat.
 * @param formBuilder Ferramenta para criação de formulários reativos.
 * @param route Serviço para interação com a rota ativa.
 * @param authService Serviço de autenticação, utilizado para gestão do estado de login do utilizador.
 * @param service Serviço para interação com a API de media (filmes e séries).
 * @param adminService Serviço para interações específicas de administradores.
 * @param gamificationService Serviço para gestão de elementos de gamificação, como medalhas.
 */
  constructor(private profileService: ProfileService,
    private chatService: ChatService,
    private formBuilder: FormBuilder,
    private route: ActivatedRoute, public authService: AuthenticationService,
    private service: MovieApiServiceComponent, private adminService: AdminService,
    private gamificationService: GamificationService) { }

  /**
   * Método chamado imediatamente após a criação do componente.
   * Subscreve a mudanças na rota ativa e ao estado de autenticação do utilizador para carregar os dados de perfil necessários.
   * Inicializa o formulário de perfil e carrega dados de media e gamificação associados ao perfil visualizado.
   */
  ngOnInit(): void {
    this.route.params.subscribe(params &#x3D;&gt; {
      if (typeof params[&#x27;username&#x27;] &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
        this.currentUsername &#x3D; params[&#x27;username&#x27;];
      }
      this.authService.user$.subscribe(user &#x3D;&gt; {
        this.loggedUserName &#x3D; user ? user.username : null;
        if (this.currentUsername &amp;&amp; this.loggedUserName &amp;&amp; this.currentUsername !&#x3D;&#x3D; this.loggedUserName) {
          this.checkFollowingStatus(this.loggedUserName, this.currentUsername);
        }
      });
      this.loadUserRole();
      if (this.currentUsername) {
        this.getUserProfileInfo(this.currentUsername);
        this.setFormFields(this.currentUsername);
        this.setImages(this.currentUsername);
        this.getFollowersList();
        this.getFollowingList();
        this.getFavorites(this.currentUsername);
        this.getWatchedMedia(this.currentUsername);
        this.getWatchLaterMedia(this.currentUsername);
        this.getMedals(this.currentUsername);
      }
    });
    this.loggedUserName &#x3D; this.authService.getLoggedInUserName();
    this.getUserProfilesMod();
    if (this.loggedUserName)
      this.profileService.getUserProfilesNotLoggedIn(this.loggedUserName).pipe(takeUntil(this.unsubscribed$)).subscribe(
        (profiles: Profile[]) &#x3D;&gt; {
          this.usersProfilesMod &#x3D; profiles;
          this.filteredUsersProfiles &#x3D; profiles;
          this.collectionSize &#x3D; profiles.length;
          this.updateSelectedUser();
          this.sortAlphabetically();
          this.filterUsers();
        },
        error &#x3D;&gt; {
          console.error(&quot;Error while fetching users&#x27; profiles:&quot;, error);
        }
      );

    if (this.usersProfilesMod.length &gt; 0) {
      this.updateSelectedUser();
    }
    this.collectionSize &#x3D; this.filteredUsersProfiles.length;
    this.getUserProfiles();
    this.initializeForm();
    this.categories &#x3D; [
      { name: &#x27;Trending Movies&#x27;, results: [], activeIndex: 0, media_type: &quot;movie&quot; },
    ];
    this.fetchTrending();
  }

  /**
  * Carrega dados de trending de media da API e atribui os resultados às categorias correspondentes.
  * Utilizado para exibir media em destaque ou mais popular na página de perfil do utilizador.
  */
  fetchTrending() {
    const fetchMethods &#x3D; [
      this.service.trendingMovieApiData(),
    ];

    fetchMethods.forEach((fetchMethod, index) &#x3D;&gt; {
      fetchMethod.subscribe((result) &#x3D;&gt; {
        this.categories[index].results &#x3D; result.results;
      });
    });
  }

  /**
  * Método chamado imediatamente antes da destruição do componente.
  * Responsável por cancelar todas as subscrições ativas para evitar memory leaks.
  */
  ngOnDestroy(): void {
    this.unsubscribed$.next();
    this.unsubscribed$.complete();
  }

   /**
   * Obtém a informação do perfil do utilizador especificado pelo nome de utilizador.
   * Atualiza a variável de estado &#x60;canViewData&#x60; baseada no status do perfil e se
   * o utilizador logado tem permissão para ver o perfil.
   * 
   * @param username Nome do utilizador do perfil a ser obtido.
   * @returns Promise&lt;void&gt; Uma promessa que resolve quando a informação do perfil
   * é obtida com sucesso ou rejeitada em caso de erro.
   */
  getUserProfileInfo(username: string): Promise&lt;void&gt; {
    return new Promise((resolve, reject) &#x3D;&gt; {
      this.profileService.getUserData(username).subscribe({
        next: (userData: Profile) &#x3D;&gt; {
          this.isProfilePublic &#x3D; userData.profileStatus;
          this.followersCount &#x3D; userData.followers;
          this.followingCount &#x3D; userData.following;
          this.userPhoto &#x3D; userData.profilePhoto;

          if (this.isProfilePublic !&#x3D;&#x3D; &#x27;Public&#x27; &amp;&amp; this.loggedUserName &amp;&amp; this.loggedUserName !&#x3D;&#x3D; username) {
            this.profileService.alreadyFollows(this.loggedUserName, username)
              .subscribe(isFollowing &#x3D;&gt; {
                this.canViewData &#x3D; isFollowing;
                resolve();
              }, error &#x3D;&gt; {
                console.error(&#x27;Erro ao verificar o status de seguimento&#x27;, error);
                this.canViewData &#x3D; false;
                reject(error);
              });
          } else {

            this.canViewData &#x3D; true;
            resolve();
          }
        },
        error: (error) &#x3D;&gt; {
          console.error(&quot;Error while fetching user data:&quot;, error);
          reject(error);
        }
      });
    });
  }

   /**
   * Carrega o papel (role) do utilizador logado para determinar se é um moderador.
   * Atualiza a propriedade &#x60;isModerator&#x60; baseada nas roles retornadas.
   */
  private loadUserRole() {
    const currentUsername &#x3D; this.authService.getLoggedInUserName();
    if (currentUsername) {
      this.authService.getUserRole(currentUsername).subscribe(roles &#x3D;&gt; {
        this.isModerator &#x3D; roles.includes(&#x27;Moderator&#x27;);
      }, error &#x3D;&gt; {
        console.error(&#x27;Error fetching roles:&#x27;, error);
      });
    }
  }

  /**
  * Inicializa o formulário com os campos padrão.
  */
  initializeForm() {
    this.profileForm &#x3D; this.formBuilder.group({
      hobby: [&#x27;&#x27;],
      gender: [&#x27;&#x27;, { disabled: true }],
      date: [&#x27;&#x27;],
    });
  }

   /**
   * Define as imagens de perfil e de capa para o utilizador especificado.
   * 
   * @param username Nome do utilizador para o qual as imagens serão definidas.
   */
  setImages(username: string) {
    this.profileService.getUserData(username).pipe(takeUntil(this.unsubscribed$)).subscribe(
      (userData: Profile) &#x3D;&gt; {
        const coverPhotoElement &#x3D; document.querySelector(&quot;.cover-photo&quot;);
        const profilePhotoElement &#x3D; document.querySelector(&quot;.profile-photo&quot;);

        if (coverPhotoElement instanceof HTMLImageElement &amp;&amp; profilePhotoElement instanceof HTMLImageElement) {
          coverPhotoElement.src &#x3D; userData.coverPhoto;
          profilePhotoElement.src &#x3D; userData.profilePhoto;
        }
      },
      error &#x3D;&gt; {
        if (error.error.errors) {
          this.errorMessages &#x3D; error.error.errors;
        } else {
          this.errorMessages.push(error.error);
        }
      }
    );
  }

   /**
   * Preenche os campos do formulário com os dados do perfil do utilizador.
   * 
   * @param username Nome do utilizador cujos dados do perfil serão utilizados para preencher o formulário.
   */
  setFormFields(username: string) {
    const userName &#x3D; document.querySelector(&quot;h1&quot;);
    this.profileForm.get(&#x27;gender&#x27;)?.disable();
    this.profileService.getUserData(username)
      .pipe(takeUntil(this.unsubscribed$))
      .subscribe({
        next: (userData: Profile) &#x3D;&gt; {
          if (userName) { userName.textContent &#x3D; username; }
          this.profileForm.patchValue({
            hobby: userData.description || &quot;Por definir&quot;,
            gender: userData.gender || &quot;Por definir&quot;,
            date: userData.birthDate ? new Date(userData.birthDate).toISOString().split(&#x27;T&#x27;)[0] : &#x27;&#x27;,
          });
          this.profileForm.get(&#x27;gender&#x27;)?.disable();
          this.followersCount &#x3D; userData.followers;
          this.followingCount &#x3D; userData.following;
        },
        error: (error) &#x3D;&gt; {
          console.error(&quot;Error while fetching user data:&quot;, error);
          if (error.error &amp;&amp; error.error.errors) {
            this.errorMessages &#x3D; error.error.errors;
          } else {
            this.errorMessages.push(error.message || &#x27;An error occurred while fetching user data.&#x27;);
          }
        }
      });
  }

   /**
   * Verifica se o utilizador autenticado segue o utilizador especificado.
   * Atualiza a propriedade &#x60;isFollowing&#x60; baseada no resultado.
   * 
   * @param usernameAuthenticated Nome do utilizador autenticado.
   * @param usernameToCheck Nome do utilizador a verificar se está a ser seguido.
   */
  checkFollowingStatus(usernameAuthenticated: string, usernameToCheck: string): void {
    this.profileService.alreadyFollows(usernameAuthenticated, usernameToCheck).subscribe(isFollowing &#x3D;&gt; {
      this.isFollowing &#x3D; isFollowing;
    }, error &#x3D;&gt; {
      console.error(&#x27;Erro ao verificar o status de seguimento&#x27;, error);
    });
  }

   /**
   * Define a propriedade &#x60;followRequestSent&#x60; como verdadeira, indicando que um pedido
   * de seguimento foi enviado.
   */
  requestToFollow(): void {
    this.followRequestSent &#x3D; true;
  }

   /**
   * Envia um pedido para seguir o utilizador atual. Atualiza as propriedades &#x60;isFollowing&#x60;
   * e &#x60;followRequestSent&#x60; baseadas na resposta.
   */
  followUser(): void {
    if (this.currentUsername &amp;&amp; this.loggedUserName) {
      this.profileService.followUser(this.loggedUserName, this.currentUsername).subscribe({
        next: () &#x3D;&gt; {
          if (this.isProfilePublic &#x3D;&#x3D;&#x3D; &#x27;Private&#x27;) {
            this.isFollowing &#x3D; false;
            this.followRequestSent &#x3D; true;
          } else {
            this.isFollowing &#x3D; true;
            this.followRequestSent &#x3D; false;
          }
        },
        error: (error) &#x3D;&gt; {
          console.error(&#x27;Erro ao seguir utilizador&#x27;, error);
        }
      });
    } else {
      console.error(&#x27;Nome de utilizador atual ou nome de utilizador logado está indefinido.&#x27;);
    }
  }

   /**
   * Envia um pedido para deixar de seguir o utilizador atual. Atualiza a propriedade &#x60;isFollowing&#x60;.
   */
  unfollowUser(): void {
    if (this.currentUsername &amp;&amp; this.loggedUserName) {
      this.profileService.unfollowUser(this.loggedUserName, this.currentUsername)
        .subscribe({
          next: () &#x3D;&gt; {
            this.isFollowing &#x3D; false;
          },
          error: (error) &#x3D;&gt; {
            console.error(&#x27;Erro ao deixar de seguir utilizador&#x27;, error);
          }
        });
    } else {
      console.error(&#x27;Os nomes de utilizador do perfil logado ou do perfil a ser seguido não estão definidos.&#x27;);
    }
  }

   /**
   * Inicia uma conversa com o utilizador atual através do serviço de chat.
   */
  sendMessageToUser(): void {
    if (this.currentUsername &amp;&amp; this.loggedUserName) {
      var profile &#x3D; {
        userName: this.currentUsername,
        profilePhoto: this.userPhoto,
        lastMessage: undefined,
      } as ProfileChat;
      this.chatService.selectUser(profile);
    } else {
      console.error(&#x27;Os nomes de utilizador do perfil logado ou do perfil a ser seguido não estão definidos.&#x27;);
    }
  }

   /**
   * Gera uma lista aleatória de seguidores ou de utilizadores que estão a seguir,
   * limitada pelo tamanho especificado.
   * 
   * @param array Array original de seguidores ou seguindo.
   * @param size Tamanho máximo da lista resultante.
   * @returns Array de &#x60;FollowerProfile&#x60; com tamanho máximo especificado e elementos aleatórios.
   */
  getRandomFollowslist(array: FollowerProfile[], size: number): FollowerProfile[] {
    const arrayCopy &#x3D; [...array];
    for (let i &#x3D; arrayCopy.length - 1; i &gt; 0; i--) {
      const j &#x3D; Math.floor(Math.random() * (i + 1));
      [arrayCopy[i], arrayCopy[j]] &#x3D; [arrayCopy[j], arrayCopy[i]];
    }
    return arrayCopy.slice(0, size);
  }

  /**
  * Obtém e atualiza a lista de seguidores do utilizador atual.
  */
  getFollowersList(): void {
    if (this.currentUsername) {
      this.profileService.getFollowers(this.currentUsername).subscribe(followers &#x3D;&gt; {
        this.followers &#x3D; this.getRandomFollowslist(followers, followers.length);
      }, error &#x3D;&gt; {
        console.error(&quot;Error while fetching followers:&quot;, error);
      });
    }
  }

   /**
   * Obtém e atualiza a lista de utilizadores que o utilizador atual está a seguir.
   */
  getFollowingList(): void {
    if (this.currentUsername) {
      this.profileService.getFollowing(this.currentUsername).subscribe(following &#x3D;&gt; {
        this.following &#x3D; this.getRandomFollowslist(following, following.length);
      }, error &#x3D;&gt; {
        console.error(&quot;Error while fetching following:&quot;, error);
      });
    }
  }

   /**
   * Gera uma lista aleatória de outros utilizadores, limitada pelo tamanho especificado.
   * 
   * @param array Array original de perfis de utilizadores.
   * @param size Tamanho máximo da lista resultante.
   * @returns Array de &#x60;Profile&#x60; com tamanho máximo especificado e elementos aleatórios.
   */
  getRandomOtherUsers(array: Profile[], size: number): Profile[] {
    const arrayCopy &#x3D; [...array];
    for (let i &#x3D; arrayCopy.length - 1; i &gt; 0; i--) {
      const j &#x3D; Math.floor(Math.random() * (i + 1));
      [arrayCopy[i], arrayCopy[j]] &#x3D; [arrayCopy[j], arrayCopy[i]];
    }
    return arrayCopy.slice(0, size);
  }

   /**
   * Obtém e atualiza a lista de perfis de utilizadores sugeridos, limitada a 5.
   */
  getUserProfiles() {
    this.profileService.getUserProfiles().pipe(takeUntil(this.unsubscribed$)).subscribe(
      (profiles: Profile[]) &#x3D;&gt; {
        this.usersProfiles &#x3D; this.getRandomOtherUsers(profiles, 5);
      },
      (error) &#x3D;&gt; {
        console.error(&quot;Error while fetching users&#x27; profiles:&quot;, error);
      }
    );
  }

  /*----------------------------------------------------------------  FAVORITOS ---------------------------------------------------------------- */

   /**
   * Obtém e processa a lista de mídias favoritas do utilizador especificado, incluindo filmes e séries.
   * Para cada mídia, busca detalhes adicionais como descrição e capa.
   * 
   * @param username Nome do utilizador cujas mídias favoritas serão obtidas.
   */
  async getFavorites(username: string): Promise&lt;void&gt; {
    try {
      const favorites &#x3D; await firstValueFrom(this.profileService.getFavoriteMedia(username));

      this.favoriteMovies &#x3D; favorites.filter(m &#x3D;&gt; m.type &#x3D;&#x3D;&#x3D; &#x27;movie&#x27;);
      this.favoriteSeries &#x3D; favorites.filter(m &#x3D;&gt; m.type &#x3D;&#x3D;&#x3D; &#x27;serie&#x27;);

      for (const movie of this.favoriteMovies) {
        try {
          const details &#x3D; await firstValueFrom(this.service.getMovieDetails(movie.mediaId));
          movie.details &#x3D; details;
        } catch (error) {
          console.error(&#x27;Erro ao buscar detalhes do filme favorito&#x27;, error);
        }
      }

      for (const series of this.favoriteSeries) {
        try {
          const details &#x3D; await firstValueFrom(this.service.getSerieDetails(series.mediaId));
          series.details &#x3D; details;
        } catch (error) {
          console.error(&#x27;Erro ao buscar detalhes da série favorita&#x27;, error);
        }
      }
    } catch (error) {
      console.error(&#x27;Erro ao buscar mídia favorita para utilizador&#x27;, username, error);
    }
  }

  /*----------------------------------------------------------------  MEDIA JÁ VISTA ---------------------------------------------------------------- */

   /**
   * Obtém e processa a lista de mídias assistidas pelo utilizador especificado, separando entre filmes e séries.
   * Busca detalhes adicionais de cada mídia assistida.
   * 
   * @param username Nome do utilizador cujas mídias assistidas serão obtidas.
   */
  async getWatchedMedia(username: string): Promise&lt;void&gt; {
    try {
      const media &#x3D; await firstValueFrom(this.profileService.getUserWatchedMedia(username));
      this.watchedMovies &#x3D; media.filter(m &#x3D;&gt; m.type &#x3D;&#x3D;&#x3D; &#x27;movie&#x27;).reverse();
      this.watchedSeries &#x3D; media.filter(m &#x3D;&gt; m.type &#x3D;&#x3D;&#x3D; &#x27;serie&#x27;).reverse();

      await this.fetchWatchedMediaDetails();
    } catch (error) {
      console.error(&#x27;Erro ao buscar mídia assistida para utilizador&#x27;, username, error);
    }
  }

   /**
   * Busca detalhes adicionais para as mídias assistidas previamente obtidas.
   */
  async fetchWatchedMediaDetails(): Promise&lt;void&gt; {
    for (const movie of this.watchedMovies) {
      try {
        const details &#x3D; await firstValueFrom(this.service.getMovieDetails(movie.mediaId));
        movie.details &#x3D; details;
      } catch (error) {
        console.error(&#x27;Erro ao buscar detalhes do filme&#x27;, error);
      }
    }

    for (const series of this.watchedSeries) {
      try {
        const details &#x3D; await firstValueFrom(this.service.getSerieDetails(series.mediaId));
        series.details &#x3D; details;
      } catch (error) {
        console.error(&#x27;Erro ao buscar detalhes da série&#x27;, error);
      }
    }
  }

  /*----------------------------------------------------------------  MEDIA A VER ---------------------------------------------------------------- */

   /**
   * Obtém e processa a lista de mídias marcadas para ver mais tarde pelo utilizador, incluindo filmes e séries.
   * Busca detalhes adicionais para cada mídia marcada.
   * 
   * @param username Nome do utilizador cujas mídias para ver mais tarde serão obtidas.
   */
  async getWatchLaterMedia(username: string): Promise&lt;void&gt; {
    try {
      const media &#x3D; await firstValueFrom(this.profileService.getUserWatchLaterMedia(username));
      this.watchLaterMovies &#x3D; media.filter(m &#x3D;&gt; m.type &#x3D;&#x3D;&#x3D; &#x27;movie&#x27;).reverse();
      this.watchLaterSeries &#x3D; media.filter(m &#x3D;&gt; m.type &#x3D;&#x3D;&#x3D; &#x27;serie&#x27;).reverse();

      await this.fetchWatchLaterMediaDetails();
    } catch (error) {
      console.error(&#x27;Erro ao buscar mídia para ver mais tarde para o utilizador&#x27;, username, error);
    }
  }

   /**
   * Busca detalhes adicionais para as mídias marcadas para ver mais tarde previamente obtidas.
   */
  async fetchWatchLaterMediaDetails(): Promise&lt;void&gt; {
    for (const movie of this.watchLaterMovies) {
      try {
        const details &#x3D; await firstValueFrom(this.service.getMovieDetails(movie.mediaId));
        movie.details &#x3D; details;
      } catch (error) {
        console.error(&#x27;Erro ao buscar detalhes do filme para ver mais tarde&#x27;, error);
      }
    }

    for (const series of this.watchLaterSeries) {
      try {
        const details &#x3D; await firstValueFrom(this.service.getSerieDetails(series.mediaId));
        series.details &#x3D; details;
      } catch (error) {
        console.error(&#x27;Erro ao buscar detalhes da série para ver mais tarde&#x27;, error);
      }
    }
  }

  /*----------------------------------------------------------------  Favoritos ----------------------------------------------------------------------- */

  toggleFavoritesList(): void {
    this.showFavorites &#x3D; !this.showFavorites;
  }

  toggleMedalsList(): void {
    this.showMedals &#x3D; !this.showMedals;
  }

  toggleFavoritesListDisplay(): void {
    this.showAllFavorites &#x3D; !this.showAllFavorites;
  }

  toggleFavoritesScroll(): void {
    this.expandedFavoritesList &#x3D; !this.expandedFavoritesList;
    this.toggleFollowers();
    this.toggleFollowing();
    this.toggleSeriesWatchedList();
    this.toggleSeriesToWatchList();
    this.toggleMoviesToWatchList();
    this.toggleMoviesWatchedList();
    this.toggleMedalsList();
  }

  /*----------------------------------------------------------------  Filmes já vistos ---------------------------------------------------------------- */

  toggleMoviesWatchedList(): void {
    this.showMoviesWatched &#x3D; !this.showMoviesWatched;
  }

  toggleMoviesWatchedListDisplay(): void {
    this.showAllMoviesWatched &#x3D; !this.showAllMoviesWatched;
  }

  toggleWatchedMoviesScroll(): void {
    this.expandedMoviesWatchList &#x3D; !this.expandedMoviesWatchList;
    this.toggleFollowers();
    this.toggleFollowing();
    this.toggleSeriesWatchedList();
    this.toggleSeriesToWatchList();
    this.toggleMoviesToWatchList();
    this.toggleFavoritesList();
    this.toggleMedalsList();
  }

  /*----------------------------------------------------------------  Filmes a ver -------------------------------------------------------------------- */

  toggleMoviesToWatchList(): void {
    this.showMoviesToWatch &#x3D; !this.showMoviesToWatch;
  }

  toggleMoviesToWatchListDisplay(): void {
    this.showAllMoviesToWatch &#x3D; !this.showAllMoviesToWatch;
  }

  toggleToWatchMoviesScroll(): void {
    this.expandedMoviesToWatchList &#x3D; !this.expandedMoviesToWatchList;
    this.toggleFollowers();
    this.toggleFollowing();
    this.toggleSeriesWatchedList();
    this.toggleMoviesWatchedList();
    this.toggleSeriesToWatchList();
    this.toggleFavoritesList();
    this.toggleMedalsList();
  }

  /*----------------------------------------------------------------  Séries já vistas ---------------------------------------------------------------- */

  toggleSeriesWatchedList(): void {
    this.showSeriesWatched &#x3D; !this.showSeriesWatched;
  }

  toggleSeriesWatchedListDisplay(): void {
    this.showAllSeriesWatched &#x3D; !this.showAllSeriesWatched;
  }

  toggleWatchedSeriesScroll(): void {
    this.expandedSeriesWatchList &#x3D; !this.expandedSeriesWatchList;
    this.toggleFollowers();
    this.toggleFollowing();
    this.toggleMoviesWatchedList();
    this.toggleSeriesToWatchList();
    this.toggleMoviesToWatchList();
    this.toggleFavoritesList();
    this.toggleMedalsList();
  }

  /*----------------------------------------------------------------  Séries a ver -------------------------------------------------------------------- */

  toggleSeriesToWatchList(): void {
    this.showSeriesToWatch &#x3D; !this.showSeriesToWatch;
  }

  toggleSeriesToWatchListDisplay(): void {
    this.showAllSeriesToWatch &#x3D; !this.showAllSeriesToWatch;
  }

  toggleToWatchSeriesScroll(): void {
    this.expandedSeriesToWatchList &#x3D; !this.expandedSeriesToWatchList;
    this.toggleFollowers();
    this.toggleFollowing();
    this.toggleMoviesWatchedList();
    this.toggleSeriesWatchedList();
    this.toggleMoviesToWatchList();
    this.toggleFavoritesList();
    this.toggleMedalsList();
  }

  /* Seguidores */

  toggleFollowers() {
    this.showFollowers &#x3D; !this.showFollowers;
  }

  toggleFollowersDisplay(): void {
    this.showAllFollowers &#x3D; !this.showAllFollowers;
  }

  toggleFollowersScroll(): void {
    this.expandedFollowers &#x3D; !this.expandedFollowers;
    this.toggleFollowersDisplay();
    this.toggleFollowing();
    this.toggleMoviesWatchedList();
    this.toggleSeriesWatchedList();
    this.toggleSeriesToWatchList();
    this.toggleMoviesToWatchList();
    this.toggleFavoritesList();
    this.toggleMedalsList();
  }

  /* A seguir */

  toggleFollowing() {
    this.showFollowing &#x3D; !this.showFollowing;
  }

  toggleFollowingDisplay(): void {
    this.showAllFollowing &#x3D; !this.showAllFollowing;
  }

  toggleFollowingScroll(): void {
    this.expandedFollowing &#x3D; !this.expandedFollowing;
    this.toggleFollowingDisplay();
    this.toggleFollowers();
    this.toggleMoviesWatchedList();
    this.toggleSeriesWatchedList();
    this.toggleSeriesToWatchList();
    this.toggleMoviesToWatchList();
    this.toggleFavoritesList();
    this.toggleMedalsList();
  }

  toggleAllFiveOtherUsers(): void {
    this.showFiveOtherUsers &#x3D; !this.showFiveOtherUsers;
  }

  toggleExpandedSuggestions() {
    this.showExpandedSuggestions &#x3D; !this.showExpandedSuggestions;
  }


  //--------------------------------------------------MEDALHAS-------------------------------------------------------------------

  /**
   * Recupera as medalhas desbloqueadas pelo utilizador.
   * Este método consulta o serviço de gamificação para obter as medalhas que o utilizador já conseguiu desbloquear.
   */
  getMedals(username: string) {
    if (this.currentUsername) {
      this.gamificationService.getUnlockedMedals(this.currentUsername).subscribe({
        next: (medals) &#x3D;&gt; {
          this.medals &#x3D; medals;
        },
        error: (err) &#x3D;&gt; {
          console.error(&#x27;Error retrieving medals:&#x27;, err);
        }
      });
    } else {
      console.error(&#x27;User ID is not defined&#x27;);
    }
  }

  //--------------------------------------------------MODERADOR------------------------------------------------------------------

  /**
   * Verifica se um utilizador está atualmente banido com base nas datas de início e fim do banimento.
   * 
   * @param profile O perfil do utilizador a verificar.
   * @returns Verdadeiro se o utilizador estiver banido, falso caso contrário.
   */
  checkIfUserIsBanned(profile: Profile): boolean {
    try {
      if (!profile.startBanDate || !profile.endBanDate) {
        return false;
      }

      const now &#x3D; new Date();
      const startBan &#x3D; new Date(profile.startBanDate);
      const endBan &#x3D; new Date(profile.endBanDate);
      const isBanned &#x3D; startBan &lt;&#x3D; now &amp;&amp; now &lt;&#x3D; endBan;

      return isBanned;
    } catch (error) {
      console.error(&#x27;Error in checkIfUserIsBanned:&#x27;, error);
      return false;
    }
  }

  /**
   * Executa o banimento temporário de um utilizador.
   * 
   * @param username O nome do utilizador a ser banido temporariamente.
   */
  banTemp(username: string | null): void {
    if (!username) {
      console.error(&#x27;Username is undefined, cannot ban user temporarily.&#x27;);
      return;
    }
    if (this.banDuration &#x3D;&#x3D; null || this.banDuration &lt;&#x3D; 0) {
      console.error(&#x27;Ban duration is not specified or is invalid.&#x27;);
      return;
    }
    console.log(&#x60;Attempting to ban user temporarily: ${username} for ${this.banDuration} days&#x60;);

    this.adminService.BanUserTemporarily(username, this.banDuration).subscribe({
      next: () &#x3D;&gt; {
        console.log(&#x60;User banned temporarily for ${this.banDuration} days&#x60;);
        const user &#x3D; this.filteredUsersProfiles?.find(u &#x3D;&gt; u.userName &#x3D;&#x3D;&#x3D; username);
        this.hideBanPopup();
        if (user) {
          user.isBanned &#x3D; true;
          this.filteredUsersProfiles &#x3D; [...this.filteredUsersProfiles!];
        }
      },
      error: error &#x3D;&gt; {
        console.error(&quot;Error banning user temporarily:&quot;, error);
      }
    });
  }

  /**
   * Executa o banimento permanente de um utilizador.
   * 
   * @param username O nome do utilizador a ser banido permanentemente.
   */
  banPerm(username: string | null): void {
    if (!username) {
      console.error(&#x27;Username is undefined, cannot ban user.&#x27;);
      return;
    }
    console.log(&#x60;Attempting to ban user permanently: ${username}&#x60;);
    this.adminService.banUserPermanently(username).subscribe({
      next: () &#x3D;&gt; {
        console.log(&#x27;User banned permanently&#x27;);
        const user &#x3D; this.filteredUsersProfiles?.find(u &#x3D;&gt; u.userName &#x3D;&#x3D;&#x3D; username);
        this.hideBanPopup();
        if (user) {
          user.isBanned &#x3D; true;
        }
        this.filteredUsersProfiles &#x3D; [...this.filteredUsersProfiles!];
      },
      error: error &#x3D;&gt; {
        console.error(&quot;Error banning user:&quot;, error);
      }
    });
  }

  /**
   * Desbane um utilizador, permitindo-lhe aceder novamente ao sistema.
   * 
   * @param username O nome do utilizador a ser desbanido.
   */
  unban(username: string | undefined): void {
    if (!username) {
      console.error(&#x27;Username is undefined, cannot unban user.&#x27;);
      return;
    }
    this.adminService.unbanUser(username).subscribe({
      next: (response) &#x3D;&gt; {
        console.log(response.message);
        const user &#x3D; this.filteredUsersProfiles?.find(u &#x3D;&gt; u.userName &#x3D;&#x3D;&#x3D; username);
        if (user) {
          user.isBanned &#x3D; false;
        }
        this.filteredUsersProfiles &#x3D; [...this.filteredUsersProfiles!];
      },
      error: (error) &#x3D;&gt; {
        console.error(&quot;Error unbanning user:&quot;, error);
      }
    });
  }

  /**
   * Exibe o popup de banimento para um utilizador selecionado.
   * 
   * @param username O nome do utilizador selecionado para banimento.
   */
  showBanPopup(username: string): void {
    this.selectedUserForBan &#x3D; username;
    this.isBanPopupVisible &#x3D; true;
  }

  /**
   * Esconde o popup de banimento e limpa a seleção de utilizador.
   */
  hideBanPopup(): void {
    this.isBanPopupVisible &#x3D; false;
    this.selectedUserForBan &#x3D; null;
  }

  /**
   * Obtém e filtra os perfis dos utilizadores, excluindo o do utilizador autenticado e enriquecendo-os com informação de moderador.
   */
  getUserProfilesMod() {
    this.profileService.getUserProfiles().pipe(
      takeUntil(this.unsubscribed$),
      map(profiles &#x3D;&gt; profiles.filter(profile &#x3D;&gt; profile.userName !&#x3D;&#x3D; this.loggedUserName)),
      mergeMap(profiles &#x3D;&gt; {
        const filteredProfiles &#x3D; profiles.filter(profile &#x3D;&gt; profile.userName !&#x3D;&#x3D; this.loggedUserName);
        const profilesWithRoles$ &#x3D; filteredProfiles.map(profile &#x3D;&gt; {
          return this.adminService.getUserRole(profile.userName).pipe(
            map(roles &#x3D;&gt; ({
              ...profile,
              isBanned: this.checkIfUserIsBanned(profile),
              isModerator: roles.includes(&#x27;Moderator&#x27;),
            })),
            catchError(error &#x3D;&gt; {
              console.error(&#x27;Error fetching roles:&#x27;, profile.userName, error);
              return of({ ...profile, isModerator: false });
            })
          );
        });
        return forkJoin(profilesWithRoles$);
      })
    ).subscribe(
      (profiles) &#x3D;&gt; {
        this.filteredUsersProfiles &#x3D; profiles;
        this.collectionSize &#x3D; profiles.length;
        this.sortAlphabetically();
        this.filterUsers();

      },
      (error) &#x3D;&gt; {
        console.error(&quot;Error while fetching users&#x27; profiles:&quot;, error);
      }
    );
  }

  /**
 * Atualiza o perfil do utilizador selecionado baseando-se no &#x60;selectedUsername&#x60;.
 * Busca e atribui o perfil correspondente a &#x60;selectedUser&#x60;.
 */
  updateSelectedUser(): void {
    this.selectedUser &#x3D; this.usersProfilesMod.find(u &#x3D;&gt; u.userName &#x3D;&#x3D;&#x3D; this.selectedUsername);
  }

  /**
   * Filtra os perfis dos utilizadores conforme o termo de pesquisa &#x60;searchTerm&#x60;.
   * Atualiza &#x60;showNoResults&#x60;, &#x60;collectionSize&#x60; e &#x60;filteredUsersProfiles&#x60; para refletir os resultados,
   * aplicando paginação baseada em &#x60;page&#x60; e &#x60;pageSize&#x60;.
   */
  filterUsers(): void {
    let filtered &#x3D; this.searchTerm ? this.usersProfilesMod.filter(user &#x3D;&gt;
      user.userName?.toLowerCase().includes(this.searchTerm.toLowerCase())) : this.usersProfilesMod;

    this.showNoResults &#x3D; filtered.length &#x3D;&#x3D;&#x3D; 0;
    this.collectionSize &#x3D; filtered.length;

    filtered &#x3D; filtered.slice((this.page - 1) * this.pageSize, this.page * this.pageSize);
    this.filteredUsersProfiles &#x3D; filtered;
  }

  /**
   * Navega para a página anterior na lista paginada de utilizadores.
   * Este método decrementa o contador de página atual e filtra novamente os utilizadores
   * para refletir a mudança na paginação.
   */
  previousPage() {
    if (this.page &gt; 1) {
      this.page--;
      this.filterUsers();
    }
  }

  /**
   * Navega para a próxima página na lista paginada de utilizadores.
   * Este método incrementa o contador de página atual e filtra novamente os utilizadores
   * para refletir a mudança na paginação, incluindo a ordenação alfabética dos utilizadores
   * se necessário.
   */
  nextPage() {
    if (this.page * this.pageSize &lt; this.collectionSize) {
      this.page++;
      this.filterUsers();
      this.sortAlphabetically();
    }
  }

  /**
  * Verifica se existe uma página anterior disponível para navegação.
  * 
  * @returns Verdadeiro se a página atual for maior que 1, indicando a existência de uma página anterior.
  */
  get hasPreviousPage(): boolean {
    return this.page &gt; 1;
  }

  /**
  * Verifica se existe uma próxima página disponível para navegação.
  * 
  * @returns Verdadeiro se o produto da página atual pelo tamanho da página for menor que o tamanho total da coleção,
  * indicando a existência de uma próxima página.
  */
  get hasNextPage(): boolean {
    return this.page * this.pageSize &lt; this.collectionSize;
  }

  /**
   * Implementa uma função de ordenação natural que compara dois perfis de utilizador.
   * 
   * @param a O primeiro perfil de utilizador para comparação.
   * @param b O segundo perfil de utilizador para comparação.
   * @returns Um número indicando a ordem dos perfis. Um valor negativo se a preceder b, positivo se b preceder a,
   * e zero se forem equivalentes na ordenação.
   */
  naturalSort(a: Profile, b: Profile): number {
    const ax: [number | typeof Infinity, string][] &#x3D; [];
    const bx: [number | typeof Infinity, string][] &#x3D; [];

    a.userName.replace(/(\d+)|(\D+)/g, function (_, $1, $2): string {
      ax.push([$1 ? Number($1) : Infinity, $2 || &quot;&quot;]);
      return &quot;&quot;;
    });
    b.userName.replace(/(\d+)|(\D+)/g, function (_, $1, $2): string {
      bx.push([$1 ? Number($1) : Infinity, $2 || &quot;&quot;]);
      return &quot;&quot;;
    });

    while (ax.length &amp;&amp; bx.length) {
      const an &#x3D; ax.shift()!;
      const bn &#x3D; bx.shift()!;
      const nn &#x3D; (an[0] - bn[0]) || an[1].localeCompare(bn[1]);
      if (nn) return nn;
    }

    return ax.length - bx.length;
  }

  /**
   * Ordena alfabeticamente os perfis de utilizadores pela propriedade userName.
   * Este método utiliza uma ordenação natural para lidar com números dentro das strings,
   * garantindo uma ordenação intuitiva para os utilizadores.
   */
  sortAlphabetically(): void {
    this.usersProfilesMod.sort((a, b) &#x3D;&gt; this.naturalSort(a, b));
    this.filterUsers();
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'MovieCategory-1.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
